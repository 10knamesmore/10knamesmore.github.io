---
title: 协变和逆变浅析浅析
date: 2025-05-23 15:23:51
tags: [泛型, 类型系统, 变性, 协变, 逆变, Rust, Java]
---
##  什么是变性（Variance）？

变性是描述**类型构造器 `F<T>` 如何随着 `T` 的子 类型关系变化**而变化的一种性质。

设 `T1 <: T2`（即 `T1` 是 `T2` 的子类型），我们关心：

> 那么 `F<T1>` 和 `F<T2>` 之间是否也存在子类型关系？

这就是变性问题的本质。

比如,对于没有构造器的raw class

```
class Animal {}
class Cat {}

animal = new Animal()
cat = new Cat()

fn f1(arg : Animal)

f1(cat)
```

这里我们可以很自然的传入一个 Cat 类型, 因为 `里氏替换原则` 的存在

> 若 S 是 T 的子类型，则程序中任何使用 T 的地方都可以使用 S 来替代，而不会影响程序的正确性。(子类实现父类的所有方法签名等)

因为没有 `类型构造器 F<> ` 所以不讨论变性的问题

也可以尝试理解为(不严谨的)  对dddd于构造器 `F<T> = T`, `F<T>` 的继承关系和 `T` 相同(`T` 和 `T` 相同,也就是 `协变` 的)

这里的构造器 `F<T>` 就是指各种语言中的含有泛型的类型,比如java的 `ArrayList<Integer>`, rust 的 `Box<dyn AnimalTrait>`

假设 `ArrayList<T>`是 `协变` 的,那么因为Cat是Animal子类, 所以 `ArrayList<Cat>` 是 `ArrayList<Animal>`的子类

假设 `ArrayList<T>`是 `逆变` 的,那么相反

那么,如果是 `不变` , 就说明上文两者没有继承关系

##  三种变性类型

| 类型构造器的行为                 | 称为                  | 数学形式       | 例子                               |
| -------------------------------- | --------------------- | -------------- | ---------------------------------- |
| `T1 <: T2` 推出 `F<T1> <: F<T2>` | 协变（Covariant）     | 子类型关系保留 | `&T`、`Option<T>` 在 Rust 中是协变 |
| `T1 <: T2` 推出 `F<T2> <: F<T1>` | 逆变（Contravariant） | 子类型关系反转 | 函数参数类型是逆变的               |
| 无法推出任何子类型关系           | 不变（Invariant）     | 没有子类型传导 | `Cell<T>`、Java 的 `List<T>`       |

##  举个例子：Rust 中的协变引用

```rust
struct Animal;
struct Cat;

fn accept(a: &Animal) {}

fn main() {
    let c: &Cat = ...;
    accept(c); // ✅ 合法，因为 `&T` 是协变的
}